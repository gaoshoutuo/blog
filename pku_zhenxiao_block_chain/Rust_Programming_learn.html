
<html lang="en">
    <head>

        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=0.5">

        <link href="http://www.yinwang.org/main.css" rel="stylesheet" type="text/css">
        <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
        <link rel="shortcut icon" href="http://www.yinwang.org/images/Yc.jpg">

        <title>自律</title>

        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                                    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-45586344-1', 'yinwang.org');
            ga('send', 'pageview');
        </script>
    </head>

    <body>
        <script>
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add('mobile');
            }
        </script>

        <!--
        <div class="ad-banner" style="margin-bottom: 5px">
            <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
            <ins class="adsbygoogle"
                    style="display:inline-block;width:100%;height:90px"
                    data-ad-client="ca-pub-1331524016319584"
                    data-ad-slot="6657867155"></ins>
            <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
        </div>
        -->

        <div class="inner">
            <h2>rust的学习</h2>
            <p>0.学rust的目的 为了web3。Polkadot的底层基础架构就是rust，新语言的geek氛围，Java已经搬砖化了。
                rust以及Go在区块链世界的广泛应用，主要是与未来可能到来的web3世界提前铺技术路。
                <span>

            </span>
            </p>

            <p>1.introduct  why Rust
                <span>
                    完全不按照这个来今天学习了
                    1 rust cargo相当于 Groovy 构建系统的
                    2 rust Crate 相当于android的jcenter 相当于 仓库字符串
                    3 let mux guess=String::new(); 相当于 String x=new String() 只不过这里的mux是可变类型还是可变参数的意思
                    4 use std::io  io::stdin.readline().expect(); 这个相当于scan且涉及到枚举 成功则前者 失败则后者
                    5 print("xxxxx{}",&mux guess)  这相当于占位的输入到print  这种占位还能拓展到什么地方吗

            </span>
            </p>

            现在用的是trpl这本中文的教材，学编程不要去做搬砖那种工作，所以我需要学习新语言。坚持就语言的探索idea创新，做独一无二的有用的东西。

            <p>2.3 章节 tour of rust Basic Types
                <span>
                    1.use std::rand::Rng   let rand::thread_rng().gen_Range(1..100);
                    2 use cmp match表达式 Ordering 分支
                    3.shadow 隐藏 同名函数的类型不匹配问题 本质就是重新指向一个新的值地址
                    4.parse 的返回样本 根据你的枚举来开启不同的分支
                    match guess.cmp(&seclet_num){
                        Ordering::Less=> xxx,
                        Ordering::Greater=> {
                            xxx
                    xxx
                    },
                    }
                    5.loop{ break} 循环+
                    6.可变变量 不可变变量 常量之间的区别，可变是 let mut 修饰  x可以等于其他类型，但是类型不能够修改，
                    不可变就是 let x  x不能直接改为其他变量，但是可以 let x这种隐藏方式的修改 并且可以修改类型。
                    常量用const 修饰 不管是默认还是其他表达式都不能够修改，常量作用域比他们大，并且不能够绑定表达式以及一些结果
                    7.隐藏说过了 就是旧瓶装新酒
                    8.有符号存储补码 - 2^n-1--2^n-1 -1 这个范围  数据类型分标量与其他复合数据类型
                    标量最常见的就是 整型 浮点 布尔 字符 正型一般都是i32 浮点 f32 f64表示单双精度的浮点数
                    bool就是 ture false  字符与其他语言的字符不一样 rust的是4字节32位的 而且是偏向unicode这样的字符，其他语言是单字符
                    9.复合类型 tuple() array[],元组 let p=(x,y,z  )let (x,y,z)=(1,2,3) print y  为5 这是解构  ,还有就是索引法  x.0 x.1, array[]
                    一般情况下是不如Vector这种标量的，但是array[1] 以及array[3,5] 3 3 3 3 3这种就很方便
                    10.值可与表达式绑定，语句就是有分号，表示式没有分号。rust静态类型语言也是先编译后输入数据，数组越界是不会出现编译错误只是，运行时错误。
                    此外值与表达式绑定不能够连等，表示式不返回结果，所以 let x=(let u=5);不行 必须 let x={let u=5;u+1}这样才可以，函数的形参是 xyz:i32这样子，
                    一般情况都是隐返回最后一个表达式。
                    trpl 3.4 之后  注释 控制流
                    nodejs 练习技术 1 把各大公链的测试账号的钱转到自己的账户里面来，实现idea也是一个不错的区块链工程师。 2 ok内部无手续费 好羊毛  大摩发行btc 的etf 需要实际质押一些btc 长期看涨。
                    分片 桥接 等等

                    他妈的一个 硕士了不起似的在这里现，教他做人。一定要找到这个狗逼。  终于查到了  果然是 山东之傻逼啊  湖北孝感  山东青岛大学本科
                    戴壮强 中核龙安有限公司 420902199412016211  北京化工大学 化学工程与技术专业  硕士论文 糖类物质厌氧消化产甲烷研究 预处理茄子秸秆与粪便共消化产甲烷性能
                    这套 通过10001 查人手机号码  支付宝微信得知 户籍地以及名字 医保系统查到姓名 学号 2017200201  湖北省孝感市孝南区陡岗镇

                    22.化学工程与技术( 266人 )

ALI, MEHRAN、ANUPHANVITTAYAKULWEERAYA、CHTAEVA, POLINA、HUSSAIN, SADAM、KHAN, MUHAMMAD AMIN、KURBONOVA, MALIKAKHON、MEREDOV EZIZ、MUHAMMAD SALMAN, MUHAMMAD SALMAN、
                    PENA JARAMILLO DIEGO FERNANDO、QURESHI,   FAISAL RAZA、SAJJAD AHMED MEMON、ULLAH, SHAKIR、丁晓青、丁瑞琴、
                    于娜、于溪佳、卫宏靓、卫玮、马佳萌、马晓东、马猛猛、马森、亓军、尹泽群、方乐、牛晨辉、王世吉、王丝雨、
                    王冬涵、王帅、王传琦、王兴栋、王吉、王佳琦、王凯宁、王泽、王迪、王宪、王钠、王悦岩、王晓冉、王钰、王铁峰、
                    王敏、王梦芸、王朝辉、王琰、王瑒、王瑞康、王骞阅、王磊、王璐、邓飞、邓逸琳、付胜男、冯利娟、卢建兴、
                    史晓飞、史理陇、甘晟勋、田济阳、申颖、白小俐、白素杭、龙新、乔宁、任远、任梦琴、关站站、刘志静、刘雨峰、
                    刘星闻、刘艳生、刘雪婷、刘鹏、刘磊、向可祺、吕希坤、吕林艺、吕泽、孙玉、孙佳星、孙浩、孙惠、孙瑞军、
                    孙瑞阳、曲雅琪、朱文龙、朱代辉、朱宇荣、朱明兰、朱俊鹏、朱思璐、朱哲、江长坤、汤金龙、许彦达、齐聪颖
                    、何奇奇、何思思、余春燕、吴长伟、吴田田、吴立夫、吴金泉、吴偲、吴翠翠、宋永猛、张心怡、张文廷、张弘立
                    、张伟宏、张冲、张红、张自东、张昆昆、张俊猛、张昰韡、张晓茹、张起毓、张维、张智超、张琪、张琪宇、张新
                    、张瑞荣、张靖、张璇、张霞、李小芳、李文思、李世良、李亚、李伟丹、李压方、李向旗、李壮举、李阳梅、李芳
                    、李牧洁、李苗、李强强、李想、李腾辉、杜晓彦、杜晓晓、杨壮、杨作波、杨宜山、杨柳、杨涛、杨积瑾、杨通、
                    杨曼、杨银花、杨越、肖振根、苏奇超、邱聪慧、邸梦宇、陈子豪、陈月亮、陈志武、陈英初、陈越颖、陈鹏、陈儒佳
                    、周广鹏、周圣杰、周冰垚、周栋波、周敏、周静、周德、孟琼宇、岳先锦、林忻、欧阳亦轩、武晓宽、武煜杰、
                    竺梦遥、罗贵莹、范丽鹏、范佳慧、范敬宜、郑凯、郑媛媛、侯创、姚怡鑫、姜亚光、姜亚庆、段思慧、胡亚飞、
                    胡振文、胡鸿炜、赵文涛、赵圣豪、赵红烨、赵玲玉、赵顺、赵晔、赵晶、郜阿旺、郝金松、唐二菊、唐开亮、
                    夏露妍、席国强、席蓝萍、徐中凯、徐莉、徐鹏飞、徐鑫、柴美彤、栾晓旭、殷婷、殷鹏、贾向碧、贾明文、
                    贾斌、郭丙炎、郭亚川、郭志伟、郭俊、郭春帅、郭栋、郭璇、钱睿创、陶童、高戈、高圣炜、高君安、高林宁、
                    高敏、高璟卉、寇伟、寇晨辉、崔思敏、崔通通、常少武、梁智清、盛浩原、黄玮康、黄朝林、黄新羿、龚亚辉、
                    龚海涛、焦一然、程玉娟、董思源、董博、谢兴泽、谢娅婷、鲁炫乡、靳俊升、鲍文静、熊浩、翟晓颖、裴丹钰、
                    谭强、滕兴宁、冀鹏、燕子翾、霍汝鹏、戴壮强、鞠昌宏
                    11. 注释 没什么好说的吧
                    12.控制流 if语句  正常就是 if num==3 {} 这样 判定条件不需要括号包起来  if也可以用condition返回值，这就很像函数式编程的语法了。
                    loop的循环可以返回 就是很奇怪的  break num*2; 默认最后一个表达式作为返回值，let result={ if num==10 break num*2;
                    };
                    while num!=0 {

                    }
                    消除了break与if等等的复杂包含
                    while 遍历
                    for遍历
                    for element in array.iter(){

                    }增加代码安全性 消除了越界的错误
                    .rev() 就是逆转方法
                    13.
                    14.
            </span>
            </p>

            <p>3.Basic Types
                <span>

            </span>
            </p>

            <p>4.introduct  why Rust
                <span>

            </span>
            </p>

            <p>4.OwnerShip
                <span>所有权是rust中比较独特的概念，其他语言里面没有我们要好好的去了解了解。
                    所有权的存在就是为了管理堆数据，堆内存数据。
                    一般语言根据内存的管理分配有三种1，像c/c++那样 使用之前先alloc申请内存，使用完成之后delete，主动申请内存主动释放内存，避免死指针与
                    野指针，防止内存泄漏，2.第二种就是Java这种GC语言，通过垃圾回收来减轻程序员的脑力负担，不需要多考虑内存分配管理，应用为零的对线都被回收。
                    3.第三种就是rust的这种所有权机制了，每个变量只能在其作用域范围内有效，且变量只能被一直指针所持有。
                    比如 let x=5 let y=x  ----与  let mut str1=String::from("hello");  str1.push_str(",World"); let s1=String::from("hello"); let s2=s1;
                    在第一段语言 我们的整型 字符 浮点 bool这些是可copy的，是直接放在栈上的常量不需要在堆上申请内存，后者字符串就是需要在堆上申请内存，在第三段这句话里面，
                    s1被s2 取代 该堆内存仅仅只可以被s2持有所有权，这里可能涉及深度浅度拷贝的问题，但是rust里面并没有这种，rust里面也有深拷贝，就是clone，浅拷贝不允许两个指针指向
                    一个变量，这样可以防止在多个指向同一个变量的指针离开作用域，该堆内存被释放多次出现错误。另外返回值是可以把所有权给传递回来   return S1;并且可以建立元组来传递多个所有权
                    变量，但是这种每次都传递所有权的变量似乎又有一些形式主义上的多余，于是我们在4.2上引入引用概念，主要传递值的引用。值的所有权，引用的所有权。有点意思。

                    fn calculate_length(s: String) -> (String, usize) {
                      let length = s.len(); // len() 返回字符串的长度
                    (s, length)
                    }
                    s传入 必须将s返回不然 出了方法体就被回收了

                    比如int bbq=10; int *p=-&-bbq;
    ·               cout<<*p<<-e-ndl-; 输出bbq的值，就是解引用操作。
                    4.2引用与借用
                    let s1=String::from("hello");
                    let len1=genLen(&s1);
                    void getLen(s1:&String)->i32{
                        s1.len();
                    }
                    传引用 与解应用

                    借用指的就是借其引用而不是占据其所有值，所以不需要还值。 &s1 指向s1的值
                    并且借用是只读并不能够去修改该值
                    例如如下的程序

                    let s1=String:from("hello");
                    addStr(&s1);
                    void addStr(s1:&String){
                    s.push_str(",World!");
                    }
                    这个程序是行不通的，但是 let mut 之后就是可变的了，这似乎是一种变化的办法。
                    这就是可变引用 &mux String
                    不可变引用允许存在多个因为他们之间互不构成竞争状态。
                    let r1 = &-s; // 没问题
let r2 = &-s; // 没问题
let r3 = &mut s; // 大问题
                    允许同时拥有不可变引用 但是不能够同时拥有可变引用
                   不可变引用不希望可变引用来改变值，导致它的尴尬。这就是不能够同时存在的原因。
                    但是引用是使用一次即失效的，所以上面的语句改为
                    let r1=&-s;
                    let r2=&-s;
                    println({}{}r1 r2)
                    let mut r3=&-3;这条语句就能用了 因为上面已经使用掉不可变引用了，当然
                  这些做法都在编译初期避免的错误，但是我觉得这种对象值竞争问题我在写Java的时候一次也没碰到这种bug问题，反倒是经常
                    烦恼根据一些参数调用方法的这种反射形式的问题。

                    悬垂指针，释放内存时保留的野指针
                    下面这个程序将说明问题
                    let &s=getM();
                    fn getM()->&String{
                    let s1=String::from("hello");
                    &-s
                    }
                    这是错误的并不会被传递出去，因为s1的生命周期仅仅只在该方法体中，离开方法体s1即被销毁，所以只能够去传值不可以传递引用。
                    在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。
引用必须总是有效的。
            </span>

                <span>
                    4.3 slice 名字看起来薄片 分片的意思。编程的思想
                    一个程序 我们要获取一段字符的第一个英文单词  奇葩 这里 搞了半天就是一个mut不对 本身也不会有人去主动的mut啊，不懂这里面的深意，slice切片语法左闭右开岂不是
                    很简单。
                    let mut s=String::from("hello world");
                    fn first_str(s:&String)->usize{
                        let bytes=s.as_bytes();
                        for(i,&item)in s.iter().enumerate(){//enumerate 这个返回 索引+字节值的元组
                            if item==b' '{
                        return i;
                    }
                    }
                    }
                    这种是错误的，因为不能够保证值的实时同步.当我们对 s.clear();时 上述i就不管用了
                    我们改进这个程序 使其传回引用不要返回值，否则不绑定同步。


                    let mut s=...;一般而言都是不可变的 不知道上面为什么弄成可变
                    fn first_str(s:&str)->&str{
                        let s1=s.as_bytes();
                        for (i,&item) in s1.iter().enumerate(){
                            if item==b' '{
                                return &s[0..i];
                    {
                    }
                    &s[..]
                    }
                    这样就能够保证绑定了
                    但是这个时候 s.clear()是错误的写法 ，网站书上写的是 不可变与可变不共存,好吧 最后&s[..]所以可变与不可变不能共存，
                    但是在这里返回的时候就不能返回&s[..] 这个已经是不可变的了，只不过slice令其可变，比较专用于字符串。
                    为什么要等到clear才是提示不共存呢。

                    &str 字符串的slice 类型
                    btc今天又是大跌  本质上 btc也是一种内卷 技术发展停滞了 于是就开始内卷了 技术从头到尾的都是工具 并不重要 学的人多了就有问题，
                    学技术没出路，大批制造红利廉价的工程师。btc消耗资源带来一小点东西
                </span>
            </p>

            <p>5.Structure&& module Enum
                <span>
                    本章比较struct 与 元组之间以异同 并通过struct构造数据结构，并且与enum构成完整的类型，struct 就像对象中的数据属性。
                    5.1 定义并实例化结构体
                    定义
                    Struct User{
                    username:String,
                    email:String,
                    signin_count:u64,
                    active:bool,
                    }
                    实例化
                    let mut user1 = User{
                    email: String::from("someone@example.com"),username: String::from("someusername123"),active: true,sign_in_count: 1,
                    };
                    //修改
                    fn rebuild_user(username:String,email:String)->User{
                        User{
                    username:username,
                    email:email,
                    sign:1,
                    active:true
                    }
                    }
                    这样有点罗嗦，当参数名称与形参名字相同的时候，可以省略形参的指定: 直接填入参数

 fn rebuild_user(username:String,email:String)->User{
                        User{
                    username,
                    email,
                    sign:1,
                    active:true
                    }
                    }

                    我们也可以使用省略式样的结构体更新语法 例如
                     let mut user2 = User{
                    email: String::from("someone@example.com"),username: String::from("someusername123"),..user1
                    };

                    元组结构体 比较简单的生产不同类型的快捷不正式方法
                    Struct Color=(i32,i32,i32);
                    Struct Point=(i32,i32,i32);

                    let black = Color(0, 0, 0);
                    let origin = Point(0, 0, 0);
                    black 与 orgin 有相同的结构 但是具有不同的类型 这就是元组结构体的使用场景

                    没有任何字段的结构体 () 我们将在第十章 trait中介绍这个工具

                    结构体中的引用
                    struct User {
                    username: &str,
                    email: &str,
                    sign_in_count: u64,
                    active: bool,
                    }
                    会报错 因为生命周期的原因 详细也要等到后面的章节

                    5.2 使用结构体的实例程序
                    构造
                    Struct Rect{
                    length:i32,
                    width:i32,
                    }

                    fn area(length:i32,width:i32)->i32{
                        return length*width;
                    }
                    我们可以直接代入值来计算面积 比如这样
                    area(50,30);
                    我们可以使用元组元组来计算面积 比如这样
                      fn area(diamons:(i32,i32))->i32{
                        return diamons.0*diamons.1;
                    }

                    area((50,30));
                    但是我们想要为其添加一些意义 必然是结构体
                    fn area(rect:&Rect))->i32{//跟前面一样 我们只想要借用对象的引用 而不是想要获取对象的所有权
                        return rect.lenth*rect.width;
                    }
                    area(&rect1);print

                    输出 结构体不是那么的容易我们可以用 {:?}` (or {:#?}
                    两种方式来输出 但是还要包含注解 impl
                    #[derive(Debug)]
                    struct Rectangle {
                        width: u32,
                        height: u32,
                    }

                    fn main() {
                        let rect1 = Rectangle { width: 30, height: 50 };

                        println!("rect1 is {:?}", rect1);
                    }
                    {:?}`  rect1 is Rectangle { width: 30, height: 50 }
                    {:#?}  rect1 is Rectangle {
                    width: 30,
                    height: 50
                }
                    两种风格

                    rust 提供了很多 derive 的注解供我们使用 但是仔细想想是不是还有结合更加紧密的方式 使得面积只可以去计算Rect这个
                    结构所指代的



                    5.3 方法语法
                    就是存在于结构体 trait 泛型 enum之内的专属方法。例如我们对 rect结构体的求area函数进行 方法语法化
                    struct rect{
                    length:i32,
                    width:i32,
                    }
                    impl rect{
                        fn area(&self)->u32{
                            return self.length*self.width;
                    }
                    }

                    这就是一种rust当中的方法语法，我们这里借用self 也就是自身的指针，并不需要持有

                    我们将方法语法放在 impl rect 块当中 然后其他方法也可以放在块当中 也可以 在开一个 impl rect块，这里面的区别第10章再说。
                    Rust中并没有一个与 ->等价的符号 这个符号在c中就是 指针的调用方法或者域。但是在rust里面 是自动解引用的，就好象如下两行代码是等价的。
                    这里也给我带来与c/c++的一种混乱，因为c/c++里面似乎对&的引用使用与指针使用是有区别的。
                    p1.get_inrect(&p2)
                    (&p1).get_inrect(&p2)
                    这两句话等价，但是我们还是喜欢第二句话 只是借用引用

                    关联函数 一种在impl里不需要实例对象self作为参数传入的方法，一般是作为为结构体返回新实例的一种函数



                    结构体并不是唯一一个创建自定义类型的方法，下面的枚举会增加你的工具箱。
                    注解 枚举 这些在Java中不是很重要的东西，在这里得到一些重视与深入，仔细研究Acala与parity web3招人的要求
                    不去练剑是错误的 江湖从未远离 需要承载更多，
                    前端工程师 后端工程师 区块链工程师 全栈工程师  属于区块链开创新时代的美好世界，去中心化被中心化压制


                    6 enum 枚举以及模式匹配
                    枚举是一种列举成员并定义类型的一种方法
                    variants 成员
                    option 一种可能有 也可能没有的各种类型的枚举
                    match 匹配适合类型的模式
                    if let 控制流枚举中的
                    rust的枚举最接近一些函数式语言 ocaml 的代数数据类型
                    双冒号就是枚举的使用类型
                    前段是跨平台的 vue react这些 但是后端 c++ java go rust 是锁死的

                    6.1 定义枚举
                    枚举里面这些成员 varivants 跟枚举本身同一个类型 并且可以去接受一个参数类型，作为一种函数。这是一种满足
                    面向对象里面的多态与继承，子类的概念。
                    不过这里既然是函数式，恐怕划分面向对象与函数式里面会有一个更深的内涵本质。思考。



                    我们举例一个枚举
                    enum ip{
                    v4,
                    v6,
                    }
                    枚举的好处在于父类与子类 对类型进行一种统一  面向对象值得就是指向基类Object
                    当我们使用枚举的时候 不知道是哪个成员 则可以用父类作为形式参数。
                    例如 fn use_enum(ip:Ip){

                    }


                    这里使用 结构体来结合一些参数
                    struct IpAddr{
                        kind:Ip,
                        addr:String,
                    }
                    let home=IpAddr{
                        kind:Ip::v4,
                        addr:String::from("127.0.0.1"),
                    }

                      let loop_out=IpAddr{
                        kind:Ip::v6,
                        addr:String::from("::1"),
                    }
                    我们也有一些简便不罗嗦的方法

                    enum Ip{
                    v4(String),
                    v6(String),
                    }
                    let home = IpAddr::V4(String::from("127.0.0.1"));

                    let loopback = IpAddr::V6(String::from("::1"));
                    直接指定  这样相当于 IP.V4 然后传值这样
                    这样我们就不需要额外的结构体了

                    我们结合枚举以及一些其他参量


                    enum Message{
                    Quit,
                    Move {x:i32,y:i32},
                    Write(String),
                    ChangeColor(i32,i32,i32),

                }
                枚举当中的特定方法
                impl Message{
                    fn call(&self){
                        //println!("this is call 123");
                    }

                    使用option 枚举来避免 空与 非空 这种不严谨的表达判断  导致空指针错误造成世界上数十e美元的损失。
                    本身的空值有可能只是某个时候是空的。
                    enum option<-T>{
                        some(T),
                        none,
                    }

                    当option可以避免一种非空但是实际是空值的情况，就像Java new出一个对象的字段是默认或者有些为null的值
                    这里option的好处

                    Option<-T> 枚举是如此有用以至于它甚至被包含在了 prelude 之中，你不需要将其显式引入作用域。另外，它的成员也是如此，
                    可以不需要 Option:: 前缀来直接使用 Some 和 None。即便如此 Option<-T> 也仍是常规的枚举，Some(T) 和 None 仍是 Option<-T> 的成员。

                    #![allow(unused)]
                    fn main() {
                    let some_number = Some(5);
                    let some_string = Some("a string");
                    let absent_number: Option<-i32> = None;
                    }
                    当指代为none的时候 就要标明其类型，这样的判空避免空指针的方式真的很不错，因为这是一种有好处的none

                    let x: i8 = 5;
                    let y: Option<-i8> = Some(5);
                    let sum = x + y;
                    这会出现错误 因为 option<-i8>与i8不能相加，必然要去转化成i8类型先

                    后面的部分主要是 option来判空的优越性 有一个真正的空值 而不是运行产生的空值

                    只要一个值不是operator<-T>类型 那么就可以显式的证明他不是空的，因为空必然要标记为op类型，
                    none是op的一个枚举类型 这是rust的一个经过深思熟虑的设计。另外了解op t 如何取t在枚举的api标准文档里面
                    自行查看，深入了解opt的使用有助于我们的rust之旅更加顺畅

                    那么类有什么用呢，在Java当中是派生承载各种函数 字段 构造的地方class，但是rust的类是分成strcut结构体与
                    enum枚举两类，分开 合作组合来组成面向对象式样的类。

                    地点：台州市行政中心2号楼4楼（台州市府大楼西侧）
                    司法考试 地点
                    电话：0576-88893996、88603597

                    （工作时间：上午8:30—12:00，下午14:30—17:30）


                    6.2 match控制运算符   给enum的一种类似if else的控制流结构

                    6.3
            </span>
            </p>

            <p>6.Expressions
                <span>

            </span>
            </p>

            <p>7.error handling
                <span>

            </span>
            </p>

        </div>
    </body>

</html>
