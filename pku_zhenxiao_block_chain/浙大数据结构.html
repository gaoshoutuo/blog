
<html lang="en">
    <head>

        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=0.5">

        <link href="http://www.yinwang.org/main.css" rel="stylesheet" type="text/css">
        <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
        <link rel="shortcut icon" href="http://www.yinwang.org/images/Yc.jpg">

        <title>自律</title>

        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                                    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-45586344-1', 'yinwang.org');
            ga('send', 'pageview');
        </script>
    </head>

    <body>
        <script>
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add('mobile');
            }
        </script>

        <!--
        <div class="ad-banner" style="margin-bottom: 5px">
            <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
            <ins class="adsbygoogle"
                    style="display:inline-block;width:100%;height:90px"
                    data-ad-client="ca-pub-1331524016319584"
                    data-ad-slot="6657867155"></ins>
            <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
        </div>
        -->

        <div class="inner">
            <h2>陈越姥姥的数据结构 PAT</h2>
            <p>兜兜转转 蹉跎好多年，就是花不出时间片来学习，来来回回好几次。要深入理解，需要借助PAT的一些实现题目来巩固自己的学习成果。这次一定行，加油。别贪心一点一点来，
            每天晚上时间利用起来虚空刷leetcode题目，公务员题目也不能放弃</p>
            <p>1.基本概念
                <span>
                    又听到姥姥的声音果然很怀念，第一章内容我都差不多急着。最长子列和的N3 N2 Nlogn N四个，就分治不算特别的明白。递归跟迭代的内存区别都已经明白了。
                    一对一线性结构
                    一对多 树结构
                    多对多就是图 集合了。
                </span>
            </p>
            <p>2.线性结构
                <span>
                  老何熟悉的课程。主要介绍的要点有
                    1.多项式的三种表示方式，及其抽象数据结构流程以及实现。
                    2.线性表的扩展 广义表，双重链表，多种链表，term
                    3.堆栈的抽象数据结构及其实现以及后缀表达式 前缀表达式，
                    11111-----多项式的三种表达方式 1 就是数组，数组下标表示其项，2类型数组结构数组也就是能够解决稀疏多项式的问题，3链表结构，也能解决稀疏多项式的问题。
                    对于数组，他的线性结构应该有定义节点类型也就是数据对象集，定义其操作集。一般有6种，make empty，findK位，insert，delete，find是否有node，length。对于数组而言插入删除的要整体的
                    前后移动效率不高，而且非排列findNode的查找效率也是On，那么链表对应的操作集也就这些，但是要对其定义一个自己的数据对象集，链表插入删除也方便，但是查找也不方便。其插入如下 先找一个P节点指向
                    i位置，s节点为新节点，s->next=p->next,p->next=s，顺序不能乱。删除操作要先由p节点i节点的前一位，后由q节点指向i节点。p-next=q-next,再对q节点回收数据。
                    22222-----广义双重链表这里很很大的空间，不要仅仅视野局限单一编程语言与单链表。下次一定？
                    33333-----前缀中缀后缀这些东西其实由树来的，但是一下子给你中缀求前缀后缀表达式都不太好求，由于有括号的存在lisp的前缀似乎可以比较的线性。但是后缀表达式在堆栈当中直接被利用。12.2我就看到这里先。

                    12.3 的确很有必要重新看一遍，我发现慢慢学，less is more 这种原则就很好，很舒服。内容很多 while p1&&p2就是两个条件至少一个被破坏才跳出
                    1.堆栈 抽象数据结构 数据集 就是堆栈stack>anthingType<，的这样一个东西。其操作集合 还是老5样 创建为空 堆栈长度 是否满 push加入 pop弹出栈顶，值得一提的是，它是先进后出的结构，想想羽毛球的球筒结构就知道。其中包含一个top的标志字段来指示当前的栈顶位置，其初始值为-1，
                    其数组的实现是   push: stack.data[++top]=item;  pop:return stack.data[top--] 其之精髓之意在这里，不考虑超出长度的情况先。中间引入如何用单个数组存储两个堆栈呢，也简单从两边向中间挤，top2-top1==1则为数组满。这样也不浪费，值得注意的是由于是两个堆栈，所以
                    又得加一个额外的标志位tag来标识加入到哪一个堆栈当中。当然我们还有链表的实现方式，先建模，我们是在堆栈顶部也就是链表的头部做操作，也就像是345这样的堆栈链表，加入头部加入2345，删除也是头部删除45，
                    有一个S节点始终指向栈顶节点，也就是数组中的top之意思。PUSH：create firsecell; first.emement=item; firstcell.next=s.next;s.next=firstcell.其pop: firstcell=s.next;s.next=firstcell.next; free firstcell;
                    堆栈的使用场景有 程序递归的调用堆栈，深度优先算法DFS，回溯backtrace算法多项式的后缀表达式，等，如果没有这个结构递归都不知道怎么去做。将中缀表达式算出需要做两步，先通过堆栈自己定义算法来变成缀表达式，再通过堆栈算一次。
                    2.队列，也是一种有所限制的线性结构。其表现形式为FIFO先来先服务，就像我们日常生活中的排队一样，第二点就是队列首部删除队列尾部插入。其抽象数据结构的数据集合，Queue的泛型数组，对了有道算法题是跟泛型数组与对象数组有什么区别的。
                    其实现方式也是两种数组跟链表，数组上的实现，队首出列之后就有空间剩余，这样会造成浪费，于是就加入了新机制环数组，但是这样满了与零状态又没法分辨，所以要们就不存满，要么就多一个标志位看看是否满。
                    好了我们就单一数组来研究其实现方法，它有两个变量 front表示对手需要删除的节点初始为-1 rear为尾部节点，初始值也为-1，然后都是递增的。push：queue.data[++rear]=element;  pop:return queue.data[++front];而链表的方式 front链表头，用来删除，rear是链表尾用来新增。
                    具体模型  front为头节点与rear为尾节点， push: q.rearNode.next=itemNode;rearNode=itemNode; pop deNode=q.frontNode.next; q,frontNode,next=deNode.next;free(deNode);大概是这样。后面就是多项式相加的小白专场了其实也没多大意思，大概就是如何使用链表来做，做点是算法如何去组织。

                </span>
            </p>

            <p>3.树 上
                <span>
                  这次看这个视频最大的目的就是为了来看树的，因为我在leetcode上面的刷题已经到了树那里了，但是对一些树的知识并不深刻，所以这次回来看一下数据结构，当然也是回应musk对于创业者想说的那句话，把时间专注在那些能令你受益终身的事情上，大概这个意思回头在看看。
                    那么什么是树呢，树就是一种用来表示层次结构最高效率的结构，一般有两种形式，静态与动态，我们的查字典就是最常见的静态查找方式，而设计数据库文件系统，文件目录的人要考虑那种动态的树结构，因为数据伴随这增删改查。等等。
                    但是说回来树最多的操作就是，插入，删除，以及遍历。修改涉及到遍历超查找这里也归为一类。。一般我们顺序结构都不是从0位置开始存储的，而是从1位开始存储，而从最后面--的循环开始查找，0位放哨兵，用来警示边界。
                    这种顺序查找的时间复杂度是On，我们选择二分查找，因为它是Ologn 但是二分查找一般适合在数组或者一些顺序的结构当中去做。如果我们把二分查找用一颗树来表示的话，是一样的。
                    那么树的深度一般的[logn]+1 ,ASL树的平均查找次数是(4*4+4*3+2*2+1)/n =3 这样。此外我们需要引入二叉查找树，因为这不仅仅是查找方便，节点的插入与删除也方便。有一些树的基本性质需要认知，树节点除根节点外有且仅有一个父节点，N个节点就有N条边，
                    术语:1.节点度 degree 就是树的分叉个数，树有几颗子树，2.树的度也就是树中节点最大的度，3.叶节点就代表度为0的树节点没有子树，4.兄弟节点也就是拥有同一个父节点的树节点。5.父节点，子节点不用在介绍了。6.
                    路径及路径长度，就是两个节点之间经过的最小边的个数，不清楚能够来一个父子回旋找表亲。7.祖先 孙子节点都是指这些的一类集合，肖老师那里的MT proof似乎有所提到，8节点层次，从1开始，根节点为1，9。树深也就是树的最大层次。
                    对于一个任意树而言有结构链表来保存节点，但是这样要么就是链表节点的结构不统一，要么就是浪费空间。所以我们引入一个新的表示方法，儿子兄弟表示法，即建立一个树节点，有left data right，左节点用来保存子节点指针，右节点用来表示最近的兄弟节点，没有的话用null表示，
                    DATA可以表示任意类型的数据。通过这种表示出来的树，再倾斜45度角，我们惊奇的发现了，这居然就是一种度为2的树，我们清晰的统一了树的结构，二叉树可以用来表示任意树。这可就派上大用场了，也就是说我们可以通过研究二叉树树性质，去解决
                    所有数据的问题。对于二叉树而言，存在这一些特殊的二叉树，斜二叉树，完美二叉树，完全二叉树，完全包含完美。对于其实现我们有两种方式，要么数组存储，要么链表存储，数据在存储完全完美二叉树上面拥有奇效。
                    对于存储，我们不仅仅要是考虑存，更重要的是如何能够读去与查找相应的节点，以及找到他们的子节点父节点。数组存储对于完全二叉树而言，找父节点则是[i/2],左子就是2i,右子就是2i+1，对于二叉树又有一种特殊的性质，n0=n2+1;.它的证明方法也不难，
                    n0+n1+n2-1=0*n0+n1+2*n2,也就是一棵树从上看从下看的不同边的边的个数相等。一般情况下我们都是用链表来实现二叉树的。这样既直观又万能好吧。好了我们说说以链表实现的树的遍历方式，总共有4种前序，中序，后序，层次。他们分别如下。
                    前序遍历:中->前->后
                        preOrderTraverSal(tree){
                            if(tree!=null)
                            printf(tree.data)
                            preOrderTraverSal(tree.left)
                            preOrderTraverSal(tree.right)
                    }
                    中序遍历:前->中->后
                      midOrderTraverSal(tree){
                            if(tree!=null)
                            midOrderTraverSal(tree.left)
                              printf(tree.data)
                            midOrderTraverSal(tree.right)
                    }
                    后序遍历:前->后->中
                     afterOrderTraverSal(tree){
                            if(tree!=null)
                            afterOrderTraverSal(tree.left)
                            afterOrderTraverSal(tree.right)
                              printf(tree.data)
                    }
                    但是不管任何的遍历方式总是On的 而且对于遍历而言用的空间也是On的，这里这张顺序图令我想到钱几个月学SICP的时候，斐波那契数列的那种非常差的不利用中间状态的递归图。
                    也许肖老师说的对，函数式编程语言熟练之后，读起来会非常的简明易用。
                    当然二叉树也可以有堆栈的遍历非递归式样的遍历，这就是leetcode上面一开始我感觉疑惑没学会儿后回来学的东西。以中序遍历为例子来表示非递归遍历我们的二叉树。
                    非递归式的迭代遍历:主要思想以中序遍历为例，就是遇到左节点先压入栈，处理中间节点，然后把右节点赋给树节点，再做循环。用代码做演示。
                    BT bt; Stack stack;
                    while(stack!=null||bt!=null){
                    while(bt!=null){
                        stack.push(bt);
                             printf(bt)//写在这里的逻辑是输出前序
                        bt=bt.left;
                    }
                    if(stack!=null){
                        bt=stack.pop()
                    printf(bt)//写在这里的逻辑是输出中序
                        bt=bt.right;
                    //后序写在这里吗 no
                    }
                    }
                    但是后序的写法可没那么简单
                      while(stack!=null||bt!=null){
                    while(bt!=null){
                        stack.push(bt);
                             printf(bt)//写在这里的逻辑是输出前序
                        bt=bt.left;
                    }
                    //前面的格式相同但是后面就不同了 要对节点新增一个标志字段 用来表示有没有被作为右节点来过
                    bt=pop();
                    stack.push(bt);//push回去
                    bt=bt.right
                    if(bt==null||isT==true)//空或者来过 出栈
                    {printf 出栈}
                    else if(bt！=null&&isT！=true)//入栈
                    {设置true 并且入栈}

                    我估摸着是这个意思。
                    。拉尼娜是西水高东水低，厄尔尼诺是东水高西水低。
                    层次遍历:我还以为层序遍历没什么花头呢，结果层序遍历的确是有点东西嗷。
                    首先它是通过队列实现的，也就是按照如下的工作顺序。1把根节点保存入队列，把根节点的左右节点保存入节点，在从队列中读取一个节点，重复做这个操作，知道队列为空为止。
                    此外我们还可以通过不同的对树节点的遍历顺序，去做很多事情例如。
                    1.寻找叶子节点，即可以在任何以递归定义的前中后序的遍历方式增加一个if判断方式，即判断左右节点是否为空来判断是否叶子节点再做一定的操作。我发现浙大数据结构的这种结构与思维都很简单，简洁有力的思想与程序。
                    2.求树的高度。当然也好做，不过要后序遍历，因为思想是递归计算左右子树的树高的max+1，以算树高。其程序遍历到底部是return 0;其他是return max+1.的这种程序的做法。这个程序值得去写一个
                    3.表达式表示树的先序 中序 后序的遍历会生成不同的前缀中缀后缀表达式，但是中缀的运算优先级有问题，需要给中序添加括号来修正。
                    4.从两个序列来构造树，关键在于必须其中一个为中序遍历序列，否则无法形成唯一树。做法很简单，首先以先中序遍历为例，我们从先序遍历的头就是根节点，然后去找中序序列中的根节点位置，前半部分就是左子树，后半部分就是右子树，然后回到前序序列，
                    分出左子树，右子树长度等等，然后左子树中的头右是左树的根节点，再重复做，也要递归左弄完右。
                    小白专场的 树通过问题 t1通过左右交换可以变化为t2则认为两树同构。这里我们使用结构链表来做比较方便输入的数据集是如下，后面指示左右节点在结构数组中的哪里。
                   4
                    A -1 1
                    B 2 3
                    C -1 -1
                    D -1 -1
                    这样，当然也可以乱序的，我们寻找根节点可以找没有指向的节点。
                    4
                    B 4 3
                    A - 0

                    D -1 -1
                    C -1 -1
                    这样的话0234都是有指向的所以只有1是没有指向则为根节点。感觉程序还得自己去写一遍，我也在某种意义上面的小白虽然听懂过了一遍，但是没有写过程序印象不深刻，还得深刻深刻下去。
                    魔鬼处于必须深刻的把知识印到脑子里与行动之上。
                </span>
            </p>
            <p>4.树 中
                <span>硅谷第六季 你知道我因为真的在乎道德理想准则，这一路上使得我吃了多少苦吗。谈论道德，talk is cheap  Understanding Compression [Book]看硅谷突然对压缩的思路 历史 算法感兴趣，此外我感兴趣交易选股算法。以此来执行。
                    美剧硅谷最后deAI能够来破解密码学的大质数。its feature not a bug.多项式时间的离散对数通用解。we build a monster we need to kill it。知道能成功就会有人无限去尝试，逆向。必须悲惨的弄死自己这没有跟随者。
                    1.二叉搜索树
                    定义就是树结构，的左节点小于自己，右节点大于自己，并且左右子树也满足这个规律。把数放在树上，线性的查找变成树上二分查找，并且树的操作非常灵活。内容并不是很多，讲课结构依旧是经典的抽象数据结构模式，讲它的操作集及其实现。
                    操作集包含 find findMax findMin insert delete等 我们一一来为其实现。
                        1.find 可递归也可循环，因为是尾递归，思想就是跟当前节点比较，如果大于当前则去右边找，如果小于当前则去左边找，否则想到就是找到返回，while也可以方便的实现。
                        2.findMax则是 一直往右边递归或者迭代直到NULL
                        3.findMin则是 一直往左边递归或者迭代直到NULL
                        4.Insert 跟find类似 逐级的去摸排大小，然后插在某个地方，递归跟迭代都可以
                        5.delete 删除就麻烦一点了，思想就是要分清删除的节点是什么节点，对于叶子节点我们知道可以直接删除，对于单一子节点的节点，也可以直接删除，并且把自己的子节点按照原来的left right顺序原原本本的插入，就像做了一个链表插入删除手术一样。
                    但是对于双子节点的删除，就有两种方面把被删除的左子树的最大节点拿来替换，并且被替换节点A的所有子树都插在A的父节点也就是子树的祖父节点上。或者拿要删节点
                    的右子树的最小节点替换，它的左右子树都并到祖父节点上，代码复杂一点但并不难，耐心总可以写出来。
                    美剧规矩的技术道德，是在是令人敬佩啊。
                    2.二叉平衡树 B树 b+树
                </span>
            </p>

            <p>5.树 下
                <span>

                </span>
            </p>

            <p>6.图 上 哇靠终于是姥姥来讲课了  培养兴趣还是快乐 先骗进来杀 我上次感觉姥姥讲课不如老何啊
                <span>

                </span>
            </p>

            <p>7.图 中
                <span>

                </span>
            </p>

            <p>8.图 下
                <span>

                </span>
            </p>

            <p>9.排序 上
                <span>

                </span>
            </p>

            <p>10.排序 下
                <span>

                </span>
            </p>

            <p>11.散列查找
                <span>

                </span>
            </p>

            <p>12.综合习题  PAT 小白专场我都没兴趣去看
                <span>

                </span>
            </p>

        </div>
    </body>

</html>
