
<html lang="en">
    <head>

        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=0.5">

        <link href="http://www.yinwang.org/main.css" rel="stylesheet" type="text/css">
        <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
        <link rel="shortcut icon" href="http://www.yinwang.org/images/Yc.jpg">

        <title>自律</title>

        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                                    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-45586344-1', 'yinwang.org');
            ga('send', 'pageview');
        </script>
    </head>

    <body>
        <script>
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add('mobile');
            }
        </script>

        <!--
        <div class="ad-banner" style="margin-bottom: 5px">
            <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
            <ins class="adsbygoogle"
                    style="display:inline-block;width:100%;height:90px"
                    data-ad-client="ca-pub-1331524016319584"
                    data-ad-slot="6657867155"></ins>
            <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
        </div>
        -->

        <div class="inner">
            <h2>陈越姥姥的数据结构 PAT</h2>
            <p>兜兜转转 蹉跎好多年，就是花不出时间片来学习，来来回回好几次。要深入理解，需要借助PAT的一些实现题目来巩固自己的学习成果。这次一定行，加油。别贪心一点一点来，
            每天晚上时间利用起来虚空刷leetcode题目，公务员题目也不能放弃</p>
            <p>1.基本概念
                <span>
                    又听到姥姥的声音果然很怀念，第一章内容我都差不多急着。最长子列和的N3 N2 Nlogn N四个，就分治不算特别的明白。递归跟迭代的内存区别都已经明白了。
                    一对一线性结构
                    一对多 树结构
                    多对多就是图 集合了。
                </span>
            </p>
            <p>2.线性结构
                <span>
                  老何熟悉的课程。主要介绍的要点有
                    1.多项式的三种表示方式，及其抽象数据结构流程以及实现。
                    2.线性表的扩展 广义表，双重链表，多种链表，term
                    3.堆栈的抽象数据结构及其实现以及后缀表达式 前缀表达式，
                    11111-----多项式的三种表达方式 1 就是数组，数组下标表示其项，2类型数组结构数组也就是能够解决稀疏多项式的问题，3链表结构，也能解决稀疏多项式的问题。
                    对于数组，他的线性结构应该有定义节点类型也就是数据对象集，定义其操作集。一般有6种，make empty，findK位，insert，delete，find是否有node，length。对于数组而言插入删除的要整体的
                    前后移动效率不高，而且非排列findNode的查找效率也是On，那么链表对应的操作集也就这些，但是要对其定义一个自己的数据对象集，链表插入删除也方便，但是查找也不方便。其插入如下 先找一个P节点指向
                    i位置，s节点为新节点，s->next=p->next,p->next=s，顺序不能乱。删除操作要先由p节点i节点的前一位，后由q节点指向i节点。p-next=q-next,再对q节点回收数据。
                    22222-----广义双重链表这里很很大的空间，不要仅仅视野局限单一编程语言与单链表。下次一定？
                    33333-----前缀中缀后缀这些东西其实由树来的，但是一下子给你中缀求前缀后缀表达式都不太好求，由于有括号的存在lisp的前缀似乎可以比较的线性。但是后缀表达式在堆栈当中直接被利用。12.2我就看到这里先。

                    12.3 的确很有必要重新看一遍，我发现慢慢学，less is more 这种原则就很好，很舒服。内容很多 while p1&&p2就是两个条件至少一个被破坏才跳出
                    1.堆栈 抽象数据结构 数据集 就是堆栈stack>anthingType<，的这样一个东西。其操作集合 还是老5样 创建为空 堆栈长度 是否满 push加入 pop弹出栈顶，值得一提的是，它是先进后出的结构，想想羽毛球的球筒结构就知道。其中包含一个top的标志字段来指示当前的栈顶位置，其初始值为-1，
                    其数组的实现是   push: stack.data[++top]=item;  pop:return stack.data[top--] 其之精髓之意在这里，不考虑超出长度的情况先。中间引入如何用单个数组存储两个堆栈呢，也简单从两边向中间挤，top2-top1==1则为数组满。这样也不浪费，值得注意的是由于是两个堆栈，所以
                    又得加一个额外的标志位tag来标识加入到哪一个堆栈当中。当然我们还有链表的实现方式，先建模，我们是在堆栈顶部也就是链表的头部做操作，也就像是345这样的堆栈链表，加入头部加入2345，删除也是头部删除45，
                    有一个S节点始终指向栈顶节点，也就是数组中的top之意思。PUSH：create firsecell; first.emement=item; firstcell.next=s.next;s.next=firstcell.其pop: firstcell=s.next;s.next=firstcell.next; free firstcell;
                    堆栈的使用场景有 程序递归的调用堆栈，深度优先算法DFS，回溯backtrace算法多项式的后缀表达式，等，如果没有这个结构递归都不知道怎么去做。将中缀表达式算出需要做两步，先通过堆栈自己定义算法来变成缀表达式，再通过堆栈算一次。
                    2.队列，也是一种有所限制的线性结构。其表现形式为FIFO先来先服务，就像我们日常生活中的排队一样，第二点就是队列首部删除队列尾部插入。其抽象数据结构的数据集合，Queue的泛型数组，对了有道算法题是跟泛型数组与对象数组有什么区别的。
                    其实现方式也是两种数组跟链表，数组上的实现，队首出列之后就有空间剩余，这样会造成浪费，于是就加入了新机制环数组，但是这样满了与零状态又没法分辨，所以要们就不存满，要么就多一个标志位看看是否满。
                    好了我们就单一数组来研究其实现方法，它有两个变量 front表示对手需要删除的节点初始为-1 rear为尾部节点，初始值也为-1，然后都是递增的。push：queue.data[++rear]=element;  pop:return queue.data[++front];而链表的方式 front链表头，用来删除，rear是链表尾用来新增。
                    具体模型  front为头节点与rear为尾节点， push: q.rearNode.next=itemNode;rearNode=itemNode; pop deNode=q.frontNode.next; q,frontNode,next=deNode.next;free(deNode);大概是这样。后面就是多项式相加的小白专场了其实也没多大意思，大概就是如何使用链表来做，做点是算法如何去组织。

                </span>
            </p>

            <p>3.树 上
                <span>
                  这次看这个视频最大的目的就是为了来看树的，因为我在leetcode上面的刷题已经到了树那里了，但是对一些树的知识并不深刻，所以这次回来看一下数据结构，当然也是回应musk对于创业者想说的那句话，把时间专注在那些能令你受益终身的事情上，大概这个意思回头在看看。
                    那么什么是树呢，树就是一种用来表示层次结构最高效率的结构，一般有两种形式，静态与动态，我们的查字典就是最常见的静态查找方式，而设计数据库文件系统，文件目录的人要考虑那种动态的树结构，因为数据伴随这增删改查。等等。
                    但是说回来树最多的操作就是，插入，删除，以及遍历。修改涉及到遍历超查找这里也归为一类。。一般我们顺序结构都不是从0位置开始存储的，而是从1位开始存储，而从最后面--的循环开始查找，0位放哨兵，用来警示边界。
                    这种顺序查找的时间复杂度是On，我们选择二分查找，因为它是Ologn 但是二分查找一般适合在数组或者一些顺序的结构当中去做。如果我们把二分查找用一颗树来表示的话，是一样的。
                    那么树的深度一般的[logn]+1 ,ASL树的平均查找次数是(4*4+4*3+2*2+1)/n =3 这样。此外我们需要引入二叉查找树，因为这不仅仅是查找方便，节点的插入与删除也方便。有一些树的基本性质需要认知，树节点除根节点外有且仅有一个父节点，N个节点就有N条边，
                    术语:1.节点度 degree 就是树的分叉个数，树有几颗子树，2.树的度也就是树中节点最大的度，3.叶节点就代表度为0的树节点没有子树，4.兄弟节点也就是拥有同一个父节点的树节点。5.父节点，子节点不用在介绍了。6.
                    路径及路径长度，就是两个节点之间经过的最小边的个数，不清楚能够来一个父子回旋找表亲。7.祖先 孙子节点都是指这些的一类集合，肖老师那里的MT proof似乎有所提到，8节点层次，从1开始，根节点为1，9。树深也就是树的最大层次。
                    对于一个任意树而言有结构链表来保存节点，但是这样要么就是链表节点的结构不统一，要么就是浪费空间。所以我们引入一个新的表示方法，儿子兄弟表示法，即建立一个树节点，有left data right，左节点用来保存子节点指针，右节点用来表示最近的兄弟节点，没有的话用null表示，
                    DATA可以表示任意类型的数据。通过这种表示出来的树，再倾斜45度角，我们惊奇的发现了，这居然就是一种度为2的树，我们清晰的统一了树的结构，二叉树可以用来表示任意树。这可就派上大用场了，也就是说我们可以通过研究二叉树树性质，去解决
                    所有数据的问题。对于二叉树而言，存在这一些特殊的二叉树，斜二叉树，完美二叉树，完全二叉树，完全包含完美。对于其实现我们有两种方式，要么数组存储，要么链表存储，数据在存储完全完美二叉树上面拥有奇效。
                    对于存储，我们不仅仅要是考虑存，更重要的是如何能够读去与查找相应的节点，以及找到他们的子节点父节点。数组存储对于完全二叉树而言，找父节点则是[i/2],左子就是2i,右子就是2i+1，对于二叉树又有一种特殊的性质，n0=n2+1;.它的证明方法也不难，
                    n0+n1+n2-1=0*n0+n1+2*n2,也就是一棵树从上看从下看的不同边的边的个数相等。一般情况下我们都是用链表来实现二叉树的。这样既直观又万能好吧。好了我们说说以链表实现的树的遍历方式，总共有4种前序，中序，后序，层次。他们分别如下。
                    前序遍历:中->前->后
                        preOrderTraverSal(tree){
                            if(tree!=null)
                            printf(tree.data)
                            preOrderTraverSal(tree.left)
                            preOrderTraverSal(tree.right)
                    }
                    中序遍历:前->中->后
                      midOrderTraverSal(tree){
                            if(tree!=null)
                            midOrderTraverSal(tree.left)
                              printf(tree.data)
                            midOrderTraverSal(tree.right)
                    }
                    后序遍历:前->后->中
                     afterOrderTraverSal(tree){
                            if(tree!=null)
                            afterOrderTraverSal(tree.left)
                            afterOrderTraverSal(tree.right)
                              printf(tree.data)
                    }
                    但是不管任何的遍历方式总是On的 而且对于遍历而言用的空间也是On的，这里这张顺序图令我想到钱几个月学SICP的时候，斐波那契数列的那种非常差的不利用中间状态的递归图。
                    也许肖老师说的对，函数式编程语言熟练之后，读起来会非常的简明易用。
                    当然二叉树也可以有堆栈的遍历非递归式样的遍历，这就是leetcode上面一开始我感觉疑惑没学会儿后回来学的东西。以中序遍历为例子来表示非递归遍历我们的二叉树。
                    非递归式的迭代遍历:主要思想以中序遍历为例，就是遇到左节点先压入栈，处理中间节点，然后把右节点赋给树节点，再做循环。用代码做演示。
                    BT bt; Stack stack;
                    while(stack!=null||bt!=null){
                    while(bt!=null){
                        stack.push(bt);
                             printf(bt)//写在这里的逻辑是输出前序
                        bt=bt.left;
                    }
                    if(stack!=null){
                        bt=stack.pop()
                    printf(bt)//写在这里的逻辑是输出中序
                        bt=bt.right;
                    //后序写在这里吗 no
                    }
                    }
                    但是后序的写法可没那么简单
                      while(stack!=null||bt!=null){
                    while(bt!=null){
                        stack.push(bt);
                             printf(bt)//写在这里的逻辑是输出前序
                        bt=bt.left;
                    }
                    //前面的格式相同但是后面就不同了 要对节点新增一个标志字段 用来表示有没有被作为右节点来过
                    bt=pop();
                    stack.push(bt);//push回去
                    bt=bt.right
                    if(bt==null||isT==true)//空或者来过 出栈
                    {printf 出栈}
                    else if(bt！=null&&isT！=true)//入栈
                    {设置true 并且入栈}

                    我估摸着是这个意思。
                    。拉尼娜是西水高东水低，厄尔尼诺是东水高西水低。
                    层次遍历:我还以为层序遍历没什么花头呢，结果层序遍历的确是有点东西嗷。
                    首先它是通过队列实现的，也就是按照如下的工作顺序。1把根节点保存入队列，把根节点的左右节点保存入节点，在从队列中读取一个节点，重复做这个操作，知道队列为空为止。
                    此外我们还可以通过不同的对树节点的遍历顺序，去做很多事情例如。
                    1.寻找叶子节点，即可以在任何以递归定义的前中后序的遍历方式增加一个if判断方式，即判断左右节点是否为空来判断是否叶子节点再做一定的操作。我发现浙大数据结构的这种结构与思维都很简单，简洁有力的思想与程序。
                    2.求树的高度。当然也好做，不过要后序遍历，因为思想是递归计算左右子树的树高的max+1，以算树高。其程序遍历到底部是return 0;其他是return max+1.的这种程序的做法。这个程序值得去写一个
                    3.表达式表示树的先序 中序 后序的遍历会生成不同的前缀中缀后缀表达式，但是中缀的运算优先级有问题，需要给中序添加括号来修正。
                    4.从两个序列来构造树，关键在于必须其中一个为中序遍历序列，否则无法形成唯一树。做法很简单，首先以先中序遍历为例，我们从先序遍历的头就是根节点，然后去找中序序列中的根节点位置，前半部分就是左子树，后半部分就是右子树，然后回到前序序列，
                    分出左子树，右子树长度等等，然后左子树中的头右是左树的根节点，再重复做，也要递归左弄完右。
                    小白专场的 树通过问题 t1通过左右交换可以变化为t2则认为两树同构。这里我们使用结构链表来做比较方便输入的数据集是如下，后面指示左右节点在结构数组中的哪里。
                   4
                    A -1 1
                    B 2 3
                    C -1 -1
                    D -1 -1
                    这样，当然也可以乱序的，我们寻找根节点可以找没有指向的节点。
                    4
                    B 4 3
                    A - 0

                    D -1 -1
                    C -1 -1
                    这样的话0234都是有指向的所以只有1是没有指向则为根节点。感觉程序还得自己去写一遍，我也在某种意义上面的小白虽然听懂过了一遍，但是没有写过程序印象不深刻，还得深刻深刻下去。
                    魔鬼处于必须深刻的把知识印到脑子里与行动之上。
                </span>
            </p>
            <p>4.树 中
                <span>硅谷第六季 你知道我因为真的在乎道德理想准则，这一路上使得我吃了多少苦吗。谈论道德，talk is cheap  Understanding Compression [Book]看硅谷突然对压缩的思路 历史 算法感兴趣，此外我感兴趣交易选股算法。以此来执行。
                    美剧硅谷最后deAI能够来破解密码学的大质数。its feature not a bug.多项式时间的离散对数通用解。we build a monster we need to kill it。知道能成功就会有人无限去尝试，逆向。必须悲惨的弄死自己这没有跟随者。
                    1.二叉搜索树
                    定义就是树结构，的左节点小于自己，右节点大于自己，并且左右子树也满足这个规律。把数放在树上，线性的查找变成树上二分查找，并且树的操作非常灵活。内容并不是很多，讲课结构依旧是经典的抽象数据结构模式，讲它的操作集及其实现。
                    操作集包含 find findMax findMin insert delete等 我们一一来为其实现。
                        1.find 可递归也可循环，因为是尾递归，思想就是跟当前节点比较，如果大于当前则去右边找，如果小于当前则去左边找，否则想到就是找到返回，while也可以方便的实现。
                        2.findMax则是 一直往右边递归或者迭代直到NULL
                        3.findMin则是 一直往左边递归或者迭代直到NULL
                        4.Insert 跟find类似 逐级的去摸排大小，然后插在某个地方，递归跟迭代都可以
                        5.delete 删除就麻烦一点了，思想就是要分清删除的节点是什么节点，对于叶子节点我们知道可以直接删除，对于单一子节点的节点，也可以直接删除，并且把自己的子节点按照原来的left right顺序原原本本的插入，就像做了一个链表插入删除手术一样。
                    但是对于双子节点的删除，就有两种方面把被删除的左子树的最大节点拿来替换，并且被替换节点A的所有子树都插在A的父节点也就是子树的祖父节点上。或者拿要删节点
                    的右子树的最小节点替换，它的左右子树都并到祖父节点上，代码复杂一点但并不难，耐心总可以写出来。
                    美剧规矩的技术道德，是在是令人敬佩啊。
                    2.二叉平衡树 B树 b+树  重复学换个老师学就通了
                    申明：本文高度，深度基数为1，但是在《数据结构与算法分析:java语言描述》这本书上，高度，深度的基数为0；两种记法都没有错，都可以用来描述树的性质，只需要标注（>0）或者(>=0)做一个区分和解释即可
                    节点n的高度 : n节点到叶子节点所有路径上包含节点个数的最大值。叶子节点的高度为1，往上节点的高度依次递增。
                    节点n的深度 : 从根节点到节点n唯一的路径的长，根节点深度为1
                    前面我们看到了，不同的插入顺序生产的不同的树，的树高度以及AVL都不一样。平均查找次数。树高度从0开始，从根结点出发最大边数，树深度就从1开始，这两句话不清楚嗷。所以我们希望树的高度尽量不要太高，于是就有了平衡二叉树，它也是搜索树。
                    平衡二叉树的定义是，任意节点的左子树以及右子树的高度之差绝对值 <=1 ,对任意节点而言。我们也很容易证明平衡二叉树的高度H与节点个数N之间存在Olog2n 的关系。对于平衡二叉树，我们有 Nh-1+Nh-2 +1=Nh,这就有点类似斐波那契数列了，我们把递推公式改为通项公式才能去验证Olog2n
                    不得已斐波那契数列也从0开始
                    H    Nh    Fh
                    0   1      1
                    1   2       1
                    2   4       2
                    3   7       3
                    4   12      5
                    5   20      8
                    6   33      13
                    7   54      21
                    8   88      34
                    Nh=Fh+2 -1  Fh 通项又是([5]^(1/2)+1)^h/[5]^(1/2)  差不多可以推出N与H的关系就是H=Olog2N的关系。
                    那么平衡二叉树 作为一种抽象数据结构，查找方便，也是有抽象数据集以及操作集的，无外乎就是老三样 find findMax findMin insert delete这些。我们来给它一一的去实现。
                    但是这里并不是去实现，但是实现也是很好实现的，只不过。这边注重的是调整。而且要多一个平衡因子，遍历这个平衡树的时候前面状态应该也要保存，不然也容易找不到的吧。find那些没什么花头都是一样的，我们重点看insert与delete，因为平衡的存在，所以插入或者删除会导致不平衡的出现。这个时候
                    就需要对树进行调整，总共有4种调整方式他们都包含了所有的不平衡需要调整的情况，这里面的知识溯源讲的不到位，但是倒是把知识点讲透了，大学陶老师就更差了感觉很赶任务一样，都不认真不仔细环境。
                    1.LL 也就是新节点插入到被破坏节点的左边的左边上，无论插在左与右边，这样顺着的ABC三个节点，就要把B提上来，B右节点的BR要给C当左节点。B的右节点是A。B的左节点是C。
                    2.RR 也就是新节点插入到被破坏节点的左边的左边上，无论插在左与右边，这样顺着的ABC三个节点，就要把B提上来，B左节点BL要给A当右节点。B的右节点是C。B的左节点是A。
                    3.LR 旋转 也就是新节点插入到被破坏节点的左边的右边上，无论插在那个节点的左与右边，这样原先的ABC就变成，C左边为B，右边为A的形式，此外CL也就是C的左节点要被当作B的右节点，CR也就是C的右节点要被当作A的左节点。因为二叉搜索树，A>CR>C>CL>B
                    4.RL 选择 也就是新节点插入到被破坏节点的左边的右边上，无论插在那个节点的左与右边，这样原先的ABC就变成,C左边为A，右边为B的形式,此外CL也就是C的左节点要被当作A的右节点，CR也就是C的右节点要被当作B的左节点。因为二叉搜索树，B>CR>C>CL>A
                    这四者关系在数据结构中的运用。
                    具体可以看笔记 也可以看ProcessOn 去怎么把笔记跟电脑笔记做漂亮，一次完美就是一件很重要的事情。
                    小白专场 不同序列生成的二叉搜索树去验证是否相同，当然是先生成然后遍历一遍看看序列是否相同。
                    1.建立树 然后看左右树是否相同
                    2.不建立树 第一个节点是根节点，大小分出左右子树，然后再划分，最后比较序列是否相同。
                    3.建立一颗基准树，其他都与此树相比较。树节点要多一个flag标志是否有被访问过
                    就是被测试序列的插入在基准树上，假如途中遇到没见过的节点就是不一致，如果途中节点都flag为0一致，那么就是一致的。这个程序需要对树中的flag进行reset，与没用到的就free。
                </span>
            </p>

            <p>5.树 下
                <span>//别想了 quant一般都是cs，数学，统计的博士搞的，听他说两句就觉得自己能赚钱那简直天方夜谭。情商势利眼女
                    1.堆 这个东西我当时看过最大堆最小堆，感觉一步步推导的过程摸不着头脑。好的我明白了最大堆了，我推一下最小堆，只要条件相反就行了
                    堆思想其实就是优先队列的Ologn化，对比较看重找到或者删除最大最小或者第几大的元素，堆并不是搜索树，搜索树最大最小在左右两边，找下去得花OlogN时间，我们要求的是有限要O1，根节点就是极大极小值，对于其抽象数据类型，
                    抽象数据集，就是树节点的根要大于左右两边任意一个子树最大，或者小于任意子树最小。其次要求他是一个完全二叉树，因为实现上，堆可以通过有数组链表或者有序数组链表，但是我们在C中还是以数组来实现堆的存储，也就是堆的生成
                    要指定一个固定长度，当然这个固定长度指的大多数时候都不是堆包含的节点个数，只是说最大能包含多少。create(len)大概是这样，然后我们来说说其操作集合，最重要的也就是insert delete create等等。
                    1.create 上面说过了 我们这里的insert与delete也以数组为准 On
                    2.先说delete因为比较容易解决，delete一般都是delete根节点，似乎不支持删除其他的任意节点。为了保持其完全二叉树的性质。好像所谓的删除与堆栈的pop相同要return出根节点，这个数据结构不是为了存储那么多正常数据，而是一些优先级数据的自调整，
                    delete掉根节点之后要把最末尾的完全叶节点顶替上来，然后进行一轮从上到下的维持最大堆的行为。具体删除要花费LogN个时间。
                    3.insert，有两种实现，一种就是插入一个节点修改成一次最大堆，再插入一个再修改成一次最大堆。这种实现的ONlogN，并不算太快的算法。我们还有更快的另一种算法，也就是先按照序列顺序，先生成完全二叉树，
                    然后我们从第N/2个节点开始做。一直到根节点去维护最大或者最小堆的这种属性，然后再从最上往下做一次最大最小堆结点的调整，最后是On个数量级的复杂度，因为他的调整次数就相当于节点的高度总和，节点的高度也就是到叶节点的边的个数，叶节点的高度为0。
                    最大堆有意思他，优先队列当中的节点优先级是在实时的变化的。堆中平衡二叉树同构，对同一个父节点的叶子节点的左右是可以交换的。

                    2.huffman 哈夫曼树 与 哈夫曼编码 想起数据压缩入门 Oreilly ，数据压缩算法，硅谷的数据压缩也是突破极限，但是极限在于数学，信息论。诶上世纪的控制论信息论牛啊。数据压缩原理与应用(第二版)，数据压缩入门  这尼玛头上在搞shama装修.
                    huffman树解决的是不同出现频率的数据应该如何去建立二叉树存储，以使得它能够以比较小的数据量去存储，其某种意义上限应该是NLogN，但是这是相当于等长信息熵的，我们的哈夫曼树编码是不等长的。这仍然可以带来编码的节约。
                    但是要避免编码的二义性质，最好是前缀码，意思就在于每个编码都位于叶节点，这样就不存在歧义，但是这种变长编码的读取，是不每次都要去编码树上去做，每次找到叶节点就算做一个。
                    此外哈夫曼编码具备一些性质
                    1不存在度为1的节点
                    2节点总个数为2倍叶节点-1
                    3左右子树交换依然是哈夫曼编码
                    4同一串编码依然存在同构
                    WPL最小也就是huffman树，在huffman编码中有应用，其建立过程就是从最小的两个频率节点开始，组装成一个新的节点，再跟一个最小的组合成一个新节点，新节点的左右节点为刚刚两个最小节点，将新节点重新插入最小堆，再如此。其中用到了最小堆，可以提
                    供最小节点。
                    硅谷的魔笛手公司pieper，引发我对于数据压缩做法以及算法的兴趣，其次哈夫曼编码最好其实也就是信息熵大小的高度。但是为了可读性也会牺牲性能。哈夫曼树为了解决，已知概率而设计最好的ASL方案的一颗树
                    3.集合以及集合运算 集合运算 加减交并查，这里面着重介绍 交集与查两个操作
                    我们通过反向的，从子节点指向父节点的树形式，也称为双亲表示法，很奇怪的名字也看不出为啥，总之这不是二叉树，连二叉也不是，何老师使用结构数组去存储这样的集合，应该是集合123都存在一个结构数组中。
                    结构数组的使用方法，专门有一个positive来存储其父节点所在数组的index
                    查操作分2步，
                    1.循环查到这个元素是否存在该结构数据当中，如果不在直接返回-1，表示不在结构数组当中
                    2.查到该元素，返回该positive不是-1的话，就返回index继续查，直到查到-1，返回这个根节点所在的index。这就算查
                    并操作就是把一个的根节点positive改成另一个根节点。陈越姥姥的那个题目意思就是查操作第一步碰到单向链表那样的数据，可能就是On2 而且不需要结构数组，普通数组也可以，直接就把一些数据映射到0-N-1的这个范围上。
                    。。。意思就是那些数据要映射在0-N-1上，所以我说计算机就是抽象与映射。

                </span>
            </p>

            <p>6.图 上 哇靠终于是姥姥来讲课了  培养兴趣还是快乐 先骗进来杀 我上次感觉姥姥讲课不如老何啊
                <span>
                    1.图介绍 感觉姥姥的课有点贵了嗷。
                    最短路径 陈家庄到王村最短 以及最小生成树的问题 村村通怎么最短。
                    图的多对多包含线性以及树的关系。DFS BFS shortPath最短路 MST最小生成树。
                    图的抽象数据结构。
                    数据集 图包含顶点以及边，图不能没有顶点可以没有边，边可以是双向的也可以是单向的，但是不能为环或者重向，两个节点之间只能有一条边。
                    操作集：insertV，insertS,deleteS,deleteV,DFS,BFS,shortPath,MST.
                    常见术语:无向图，有向图，权重图-网络。以后的东西用到在说。
                    如何在程序中表示一个图，两种方法。
                    邻接矩阵法:G[N][N].问题网络中的Vi Vj，就是开一个二维数组去存储，很明显对角线上全为0，因为没有自回路，并且是对称的，有浪费，实际情况可以用一个G[N*(N+1)/2]的一维数组，的确是要多出N/2的个数。
                    那么这么存储方式也带来了新的问题，也就是一个原本的G[i][j]的值在这上面就不好找了。我们就有新的公式，i*(i+1)/2+j,就是原先G[i][j]再此的坐标。也很明白就是上面那个三角形按照原来上面的公式多出i/2,
                    后面那行的j就是多余的偏移量加上去。
                    对于邻接矩阵表示法，优点在于:1.表示非常的简洁易懂，方便检查任意一对节点是否有边，方便找任意节点所有的邻节点即行列非0，方便计算任意节点的度，有向图的出度与入度，行非零为出度，列非零为入度，无向图就是行列的非0元素。
                    缺点在于:浪费空间，浪费时间
                    假如没有连接的话需要用什么来表示也是0吗。
                    第二种表示法:邻接表 G[N] 指针数组，每个节点连接什么一次用链表挂上去，每个节点也没被存储两次，也不怎么省空间，一定要比较稀疏才可以用。因为用到了N个节点+2E个节点，
                    有点在于方便找到一个节点所有的邻节点，对于无向图而言是方便计算度，但是对于有向图也只是出度方面，入度不方便，入度需要建立逆邻接表，即所有原先邻接矩阵列的数据，并且
                    不方便检查任意两个节点之间是否存在边，能检查不方便。
                    实际上图并不仅仅有这两种方法去表示，就是之前的数组与链表应该也是这样的。

                    2.图遍历
                    图遍历解决一些有趣的问题
                    DFS 深度优先搜索 类似树遍历中的先序遍历
                    对于邻接表就是O(V+E),每个每个边都访问一次，对于邻接矩阵就是O(N2)有N行，每行都访问一边。
                    void DFS(V)
                        visit[v]=true
                        for(V的邻接点W)
                            w为false DFS[w]

                    BFS 广度优先搜索 姥姥用的是迭代循环 我先入为主的用递归。树的层序遍历，也要要到队列 要记住 奥赛 竞赛 学习书
                    void BFS(V)
                        visit[v]=true
                        addQueue(Q)
                    while(Q not empty)
                        v=delQ;
                        for(V周围的W)
                            if visit[W]==false
                                visit[w]=true
                                addQueue(W)
                    图中的其他概念
                    连通:图中任意两节点都有路径
                    路径:图中所有顶点连接之集合
                    连通图:所有节点都连通的图
                    回路:起点与终点同一个的图
                    连通分量:要么不能新增节点导致非联通图，要不不能额外新增边
                    强连通:无向的连通图

                    设计有趣味的，设计有意思的。趣味性
                    我们为什么要设计两种不同的遍历方式呢，结果是不一样的，若是我们遍历那些不连通的图怎么办呢，就需要借助这两个遍历方式
                    for(G 中的V)
                        DFS(V)/BFS(V)
                    3.应用实例-1 暴露年龄的007 图编码
                    007跳跃距离，鳄鱼邻接表，到岸边的距离，然后DFS 找到就是找到 找不到就是找不到。数学题目一般都是抽象出来，计算机也讲抽象，但是没数学这么抽象三生万物的感觉，计算机有这些有趣的实例题目来做。

                    4.应用实例-2    社交6度空间理论，就是V节点邻接结构表，这个结构数组要增加一个字段来显示layer。算法思路就是进行广度优先搜索，这样可以看层数，进行深优先行不行，应该可以。
                    然后广度层序遍历在到自己，layer++,这样
                    5.小白专场 建立图 很简单邻接矩阵  WeightType G[MaxNum][MaxNum] int vNum;int eNum; =1为由边 =0为没有 这样对于一个砌猪圈的程序员是已经够了，但是对于我们这些高大上的工程师可是不够的，
                    我们工程师考虑的问题，或许是在一个大的系统中去设计一个小的模块，满足两点性质，高可用性通用性，以及可读性，能够被其他同事看懂。建立图要先建立结构，然后一条条的为图建立边，
                    虽然香港比较的珠光宝气，拜金封建，可是
                </span>
            </p>

            <p>7.图 中
                <span>
                    1.3个树习题，但是为什么要在图里面再讲。上传资料总是不改变还是12年的，感觉就有一点沽名钓誉。算了 DFS BFS
                     这应该是树的习题，各位对于知识是如何去对待的呢，就像你们在学校中学到，正视你们学习态度。
                    树的再遍历 堆栈非递归的中序遍历  对于push就是先序，对于pop就是中序。然后我们的先序中序出来了，后序也能出来了。问题最开始的序列要建立树，或者建立堆栈。
                    2 完全二叉树
                    3 huffman code 一定是最优的，但是最优不一定huffman。判断最优编码一定要建立huffman树，因为满足没有度为1，以及是前缀码不一定就是最优WPL。

                    2.最短路:最短路包含的问题其实是一系列的问题，并不仅仅是最短路，知识图论当中的最短路，其他还包含最少价格，最少停靠之类，这些都是有其他字段在帮忙平时要多多留意
                    单源:从固定源点出发去到求其到所有其他顶点最短路径
                        无权图：其实就是类似BFS的算法，只要有边就+1，但是我们这里不需要visit[v],我们需要新建两个数组，dist[w]=dist[v]+1,path[w]=v;意思就是后一个的距离就是前一个节点的距离+1.当然还得通过距离不可能是某个奇特的值，最后我们通过
                    最后的w节点可以一路反推回，但是要没一个都可以推出前一个节点v，直到推到起点，但是顺序列还是要依靠我们的堆栈来做逆向。
                    时间复杂度O E+V 但是这是邻接表的情况下，我们还有邻接矩阵的情况
                    这个条件。path[w]保存到其的前一个节点，这样
                        有权图:最短路，这是有权了要加权了，仍然有负值圈这点要比较，要记住我们是在递增的寻找最短路。Dijkstra,金光闪闪登场，比较复杂，思想就是S集合包含s源点以及一系列的vi节点，
                    min(dist[w],dist[v]+v->w),这里的意思就是新增节点v使得原先的dist[w]变小，那么v一定过程性在这个最短路当中，因为最短并且不存在其他vi会在 s-v-w ,v的前部分，因为递增的关系，这已经是最笑了，
                    s-vi-v-w一定比s-v-w长，而且也不可能在后面，因为这是新增
                    多源:
                        可以是对所有顶点做单源最短路，但是有别的方法比较快速。
                </span>
            </p>

            <p>8.图 下
                <span>
                    1.最小树
                    2.拓扑排序
                </span>
            </p>

            <p>9.排序 上  作孽啊，这个大三上的数据结构课又得他妈再来一遍，这下得要过代码，认真认真一板一眼的去学习。
                <span>
                    1.简单排序-冒泡-插入
                    2.希尔
                    3.堆排序
                    4.归并排序
                </span>
            </p>

            <p>10.排序 下
                <span>
                    1.快速排序
                </span>
            </p>

            <p>11.散列查找
                <span>

                </span>
            </p>

            <p>12.综合习题  PAT 小白专场我都没兴趣去看
                <span>

                </span>
            </p>

        </div>
    </body>

</html>
