
<html lang="en">
    <head>

        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=0.5">

        <link href="http://www.yinwang.org/main.css" rel="stylesheet" type="text/css">
        <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
        <link rel="shortcut icon" href="http://www.yinwang.org/images/Yc.jpg">

        <title>自律</title>

        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                                    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-45586344-1', 'yinwang.org');
            ga('send', 'pageview');
        </script>
    </head>

    <body>
        <script>
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent))
            {
               document.body.classList.add('mobile');
            }
        </script>

        <!--
        <div class="ad-banner" style="margin-bottom: 5px">
            <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
            <ins class="adsbygoogle"
                    style="display:inline-block;width:100%;height:90px"
                    data-ad-client="ca-pub-1331524016319584"
                    data-ad-slot="6657867155"></ins>
            <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
        </div>
        -->

        <div class="inner">
            <h2>陈越姥姥的数据结构 PAT</h2>
            <p>兜兜转转 蹉跎好多年，就是花不出时间片来学习，来来回回好几次。要深入理解，需要借助PAT的一些实现题目来巩固自己的学习成果。这次一定行，加油。别贪心一点一点来，
            每天晚上时间利用起来虚空刷leetcode题目，公务员题目也不能放弃</p>
            <p>1.基本概念
                <span>
                    又听到姥姥的声音果然很怀念，第一章内容我都差不多急着。最长子列和的N3 N2 Nlogn N四个，就分治不算特别的明白。递归跟迭代的内存区别都已经明白了。
                    一对一线性结构
                    一对多 树结构
                    多对多就是图 集合了。
                </span>
            </p>
            <p>2.线性结构
                <span>
                  老何熟悉的课程。主要介绍的要点有
                    1.多项式的三种表示方式，及其抽象数据结构流程以及实现。
                    2.线性表的扩展 广义表，双重链表，多种链表，term
                    3.堆栈的抽象数据结构及其实现以及后缀表达式 前缀表达式，
                    11111-----多项式的三种表达方式 1 就是数组，数组下标表示其项，2类型数组结构数组也就是能够解决稀疏多项式的问题，3链表结构，也能解决稀疏多项式的问题。
                    对于数组，他的线性结构应该有定义节点类型也就是数据对象集，定义其操作集。一般有6种，make empty，findK位，insert，delete，find是否有node，length。对于数组而言插入删除的要整体的
                    前后移动效率不高，而且非排列findNode的查找效率也是On，那么链表对应的操作集也就这些，但是要对其定义一个自己的数据对象集，链表插入删除也方便，但是查找也不方便。其插入如下 先找一个P节点指向
                    i位置，s节点为新节点，s->next=p->next,p->next=s，顺序不能乱。删除操作要先由p节点i节点的前一位，后由q节点指向i节点。p-next=q-next,再对q节点回收数据。
                    22222-----广义双重链表这里很很大的空间，不要仅仅视野局限单一编程语言与单链表。下次一定？
                    33333-----前缀中缀后缀这些东西其实由树来的，但是一下子给你中缀求前缀后缀表达式都不太好求，由于有括号的存在lisp的前缀似乎可以比较的线性。但是后缀表达式在堆栈当中直接被利用。12.2我就看到这里先。

                    12.3 的确很有必要重新看一遍，我发现慢慢学，less is more 这种原则就很好，很舒服。内容很多 while p1&&p2就是两个条件至少一个被破坏才跳出
                    1.堆栈 抽象数据结构 数据集 就是堆栈stack>anthingType<，的这样一个东西。其操作集合 还是老5样 创建为空 堆栈长度 是否满 push加入 pop弹出栈顶，值得一提的是，它是先进后出的结构，想想羽毛球的球筒结构就知道。其中包含一个top的标志字段来指示当前的栈顶位置，其初始值为-1，
                    其数组的实现是   push: stack.data[++top]=item;  pop:return stack.data[top--] 其之精髓之意在这里，不考虑超出长度的情况先。中间引入如何用单个数组存储两个堆栈呢，也简单从两边向中间挤，top2-top1==1则为数组满。这样也不浪费，值得注意的是由于是两个堆栈，所以
                    又得加一个额外的标志位tag来标识加入到哪一个堆栈当中。当然我们还有链表的实现方式，先建模，我们是在堆栈顶部也就是链表的头部做操作，也就像是345这样的堆栈链表，加入头部加入2345，删除也是头部删除45，
                    有一个S节点始终指向栈顶节点，也就是数组中的top之意思。PUSH：create firsecell; first.emement=item; firstcell.next=s.next;s.next=firstcell.其pop: firstcell=s.next;s.next=firstcell.next; free firstcell;
                    堆栈的使用场景有 程序递归的调用堆栈，深度优先算法DFS，回溯backtrace算法多项式的后缀表达式，等，如果没有这个结构递归都不知道怎么去做。将中缀表达式算出需要做两步，先通过堆栈自己定义算法来变成缀表达式，再通过堆栈算一次。
                    2.队列，也是一种有所限制的线性结构。其表现形式为FIFO先来先服务，就像我们日常生活中的排队一样，第二点就是队列首部删除队列尾部插入。其抽象数据结构的数据集合，Queue的泛型数组，对了有道算法题是跟泛型数组与对象数组有什么区别的。
                    其实现方式也是两种数组跟链表，数组上的实现，队首出列之后就有空间剩余，这样会造成浪费，于是就加入了新机制环数组，但是这样满了与零状态又没法分辨，所以要们就不存满，要么就多一个标志位看看是否满。
                    好了我们就单一数组来研究其实现方法，它有两个变量 front表示对手需要删除的节点初始为-1 rear为尾部节点，初始值也为-1，然后都是递增的。push：queue.data[++rear]=element;  pop:return queue.data[++front];而链表的方式 front链表头，用来删除，rear是链表尾用来新增。
                    具体模型  front为头节点与rear为尾节点， push: q.rearNode.next=itemNode;rearNode=itemNode; pop deNode=q.frontNode.next; q,frontNode,next=deNode.next;free(deNode);大概是这样。后面就是多项式相加的小白专场了其实也没多大意思，大概就是如何使用链表来做，做点是算法如何去组织。

                </span>
            </p>

            <p>3.树 上
                <span>
                  这次看这个视频最大的目的就是为了来看树的，因为我在leetcode上面的刷题已经到了树那里了，但是对一些树的知识并不深刻，所以这次回来看一下数据结构，当然也是回应musk对于创业者想说的那句话，把时间专注在那些能令你受益终身的事情上，大概这个意思回头在看看。
                    那么什么是树呢，树就是一种用来表示层次结构最高效率的结构，一般有两种形式，静态与动态，我们的查字典就是最常见的静态查找方式，而设计数据库文件系统，文件目录的人要考虑那种动态的树结构，因为数据伴随这增删改查。等等。
                    但是说回来树最多的操作就是，插入，删除，以及遍历。修改涉及到遍历超查找这里也归为一类。。一般我们顺序结构都不是从0位置开始存储的，而是从1位开始存储，而从最后面--的循环开始查找，0位放哨兵，用来警示边界。
                    这种顺序查找的时间复杂度是On，我们选择二分查找，因为它是Ologn 但是二分查找一般适合在数组或者一些顺序的结构当中去做。如果我们把二分查找用一颗树来表示的话，是一样的。
                    那么树的深度一般的[logn]+1 ,ASL树的平均查找次数是(4*4+4*3+2*2+1)/n =3 这样。此外我们需要引入二叉查找树，因为这不仅仅是查找方便，节点的插入与删除也方便。有一些树的基本性质需要认知，树节点除根节点外有且仅有一个父节点，N个节点就有N条边，
                    术语:1.节点度 degree 就是树的分叉个数，树有几颗子树，2.树的度也就是树中节点最大的度，3.叶节点就代表度为0的树节点没有子树，4.兄弟节点也就是拥有同一个父节点的树节点。5.父节点，子节点不用在介绍了。6.
                    路径及路径长度，就是两个节点之间经过的最小边的个数，不清楚能够来一个父子回旋找表亲。7.祖先 孙子节点都是指这些的一类集合，肖老师那里的MT proof似乎有所提到，8节点层次，从1开始，根节点为1，9。树深也就是树的最大层次。
                    对于一个任意树而言有结构链表来保存节点，但是这样要么就是链表节点的结构不统一，要么就是浪费空间。所以我们引入一个新的表示方法，儿子兄弟表示法，即建立一个树节点，有left data right，左节点用来保存子节点指针，右节点用来表示最近的兄弟节点，没有的话用null表示，
                    DATA可以表示任意类型的数据。通过这种表示出来的树，再倾斜45度角，我们惊奇的发现了，这居然就是一种度为2的树，我们清晰的统一了树的结构，二叉树可以用来表示任意树。这可就派上大用场了，也就是说我们可以通过研究二叉树树性质，去解决
                    所有数据的问题。对于二叉树而言，存在这一些特殊的二叉树，斜二叉树，完美二叉树，完全二叉树，完全包含完美。对于其实现我们有两种方式，要么数组存储，要么链表存储，数据在存储完全完美二叉树上面拥有奇效。
                    对于存储，我们不仅仅要是考虑存，更重要的是如何能够读去与查找相应的节点，以及找到他们的子节点父节点。数组存储对于完全二叉树而言，找父节点则是[i/2],左子就是2i,右子就是2i+1，对于二叉树又有一种特殊的性质，n0=n2+1;.它的证明方法也不难，
                    n0+n1+n2-1=0*n0+n1+2*n2,也就是一棵树从上看从下看的不同边的边的个数相等。一般情况下我们都是用链表来实现二叉树的。这样既直观又万能好吧。好了我们说说以链表实现的树的遍历方式，总共有4种前序，中序，后序，层次。他们分别如下。
                    前序遍历:中->前->后
                        preOrderTraverSal(tree){
                            if(tree!=null)
                            printf(tree.data)
                            preOrderTraverSal(tree.left)
                            preOrderTraverSal(tree.right)
                    }
                    中序遍历:前->中->后
                      midOrderTraverSal(tree){
                            if(tree!=null)
                            midOrderTraverSal(tree.left)
                              printf(tree.data)
                            midOrderTraverSal(tree.right)
                    }
                    后序遍历:前->后->中
                     afterOrderTraverSal(tree){
                            if(tree!=null)
                            afterOrderTraverSal(tree.left)
                            afterOrderTraverSal(tree.right)
                              printf(tree.data)
                    }
                    但是不管任何的遍历方式总是On的 而且对于遍历而言用的空间也是On的，这里这张顺序图令我想到钱几个月学SICP的时候，斐波那契数列的那种非常差的不利用中间状态的递归图。
                    也许肖老师说的对，函数式编程语言熟练之后，读起来会非常的简明易用。
                    当然二叉树也可以有堆栈的遍历非递归式样的遍历，这就是leetcode上面一开始我感觉疑惑没学会儿后回来学的东西。以中序遍历为例子来表示非递归遍历我们的二叉树。



                    。拉尼娜是西水高东水低，厄尔尼诺是东水高西水低。
                    层次遍历:
                </span>
            </p>
            <p>4.树 中
                <span>
                    1.二叉搜索树
                    2.二叉平衡树 B树 b+树
                </span>
            </p>

            <p>5.树 下
                <span>

                </span>
            </p>

            <p>6.图 上 哇靠终于是姥姥来讲课了  培养兴趣还是快乐 先骗进来杀 我上次感觉姥姥讲课不如老何啊
                <span>

                </span>
            </p>

            <p>7.图 中
                <span>

                </span>
            </p>

            <p>8.图 下
                <span>

                </span>
            </p>

            <p>9.排序 上
                <span>

                </span>
            </p>

            <p>10.排序 下
                <span>

                </span>
            </p>

            <p>11.散列查找
                <span>

                </span>
            </p>

            <p>12.综合习题  PAT 小白专场我都没兴趣去看
                <span>

                </span>
            </p>

        </div>
    </body>

</html>
